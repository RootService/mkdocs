#!/bin/sh -eu
#
#  **********************************************************************************
#  *                               update-pftables.sh                               *
#  *                            ------------------------                            *
#  *                                                                                *
#  **********************************************************************************
#  * MIT License                                                                    *
#  * Copyright Â© 2016-2025 Markus Kohlmeyer <rootservice@gmail.com>                 *
#  **********************************************************************************
#
#   FreeBSD PF table updater script (POSIX /bin/sh compatible)
#   Requires: pfctl, curl, expiretable, whois, awk, sed, mktemp, xargs, etc.
#
#   Usage: update-pftables [--help] [--version]
#

set -o errexit
set -o nounset
set -o pipefail

# Use safe PATH
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
export PATH TZ=UTC LC_ALL=C

####################################################################################
#                               Configurable Variables                             #
####################################################################################
VERSION="1.1.1"
AUTHORS="Markus Kohlmeyer"
CONTACT="<rootservice@gmail.com>"
COPYRIGHT="Copyright (C) 2016-2025 Markus Kohlmeyer"
REPORTS="https://github.com/RootService/mkdocs"

# Files & Directories
LOG_FILE="/var/log/$(basename "$0").log"
TMP_DIR="$(mktemp -d -q /tmp/$(basename "$0").XXXXXXXX)" || { echo "Failed to create TMP_DIR"; exit 1; }
TMP_FILE="$(mktemp -q /tmp/$(basename "$0").XXXXXXXX)" || { echo "Failed to create TMP_FILE"; exit 1; }

# User agent
USER_AGENT="Mozilla/5.0 (FreeBSD 14.3; x86_64; x64; rv:142.0) Gecko/20100101 Firefox/142.0"

# Commands: detect using command -v
CURL_CMD="$(command -v curl 2>/dev/null || echo /usr/local/bin/curl)"
EXPIRETABLE_CMD="$(command -v expiretable 2>/dev/null || echo /usr/local/sbin/expiretable)"

####################################################################################
#                               Dependency Checks                                  #
####################################################################################
missing=""
for cmd in whoami cat date tr awk sed grep find xargs cut sort uniq head tail \
           cp mv rm chmod chown mktemp service wc gzip make pfctl whois \
           "$CURL_CMD" "$EXPIRETABLE_CMD"; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    missing="$missing $cmd"
  fi
done
if [ -n "$missing" ]; then
  echo "Missing required commands:$missing"
  exit 1
fi

####################################################################################
#                                   Color Output                                   #
####################################################################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
WHITE='\033[0;37m'
NC='\033[0m'

cecho() {
  color="$1"
  shift
  printf "%b%s%b\\n" "$(eval echo "\${$color}")" "$*" "$NC"
}
cechon() {
  color="$1"
  shift
  printf "%b%s%b" "$(eval echo "\${$color}")" "$*" "$NC"
}

####################################################################################
#                                    Logging                                       #
####################################################################################
log() {
  level="$1"
  shift
  message="$*"
  printf "%s [%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "${level}" "${message}" >> "$LOG_FILE"
}

show_text()  { cecho WHITE "$*"; log TEXT "$*"; }
show_info()  { cecho GREEN "$*"; log INFO "$*"; }
show_warn()  { cecho YELLOW "$*"; log WARN "$*"; }
show_error() { cecho RED "$*"; log ERROR "$*"; }

# Log rotation (compress old logs for efficiency)
if [ -f "$LOG_FILE" ] && [ "$(stat -f%z "$LOG_FILE")" -gt 1048576 ]; then
  mv "$LOG_FILE" "$LOG_FILE.old"
  gzip -f "$LOG_FILE.old" 2>/dev/null || true
  : > "$LOG_FILE"
fi

####################################################################################
#                                 Utility Functions                                #
####################################################################################
tolower() { [ -n "${1:-}" ] && echo "$*" | tr '[:upper:]' '[:lower:]'; }
toupper() { [ -n "${1:-}" ] && echo "$*" | tr '[:lower:]' '[:upper:]'; }

read_prompt() {
  prompt="${1}"
  var="${2:-REPLY}"
  input=""
  while :; do
    cechon WHITE "$prompt "
    IFS= read -r input
    # Only printable ASCII
    if [ -z "$(printf '%s' "$input" | tr -d '\040-\176')" ]; then
      eval "$var=\"\$input\""
      break
    else
      show_warn "Non-printable char(s) detected! Please retry..."
    fi
  done
}

read_passwd() {
  prompt="${1}"
  var="${2:-REPLY}"
  input=""
  while :; do
    cechon WHITE "$prompt "
    stty -echo
    IFS= read -r input
    stty echo
    echo
    if [ -z "$(printf '%s' "$input" | tr -d '\040-\176')" ]; then
      eval "$var=\"\$input\""
      break
    else
      show_warn "Non-printable char(s) detected! Please retry..."
    fi
  done
}

rootonly() {
  [ "$(id -u)" = "0" ] || { show_error "You must be root to run this script!"; exit 1; }
}

print_separator() {
  printf "================================================================================\n"
}

cleanup() {
  rm -rf "$TMP_DIR" "$TMP_FILE"
}

trap 'show_error "Script interrupted. Exiting."; cleanup; exit 1' INT TERM
trap 'cleanup' EXIT

####################################################################################
#                                 Argument Parsing                                 #
####################################################################################
show_usage() {
  cat <<EOF >&2
Usage: $(basename "$0") [OPTIONS]

OPTIONS:
  -h|--help         Display this help and exit
  -v|--version      Output version information and exit

${COPYRIGHT} ${CONTACT}
Written by ${AUTHORS}
Report any bugs to: ${REPORTS}
EOF
  exit 1
}

show_version() {
  cat <<EOF >&2
$(basename "$0") ${VERSION}

${COPYRIGHT} ${CONTACT}
Written by ${AUTHORS}
MIT License
EOF
  exit 0
}

# Basic getopts (no long options in POSIX getopts)
dryrun=0
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help) show_usage ;;
    -v|--version) show_version ;;
    --dry-run) dryrun=1 ;;
    --) shift; break ;;
    -*) show_usage ;;
    *) break ;;
  esac
  shift
done

####################################################################################
#                                   Main Logic                                     #
####################################################################################
rootonly

print_separator
show_info "Started updating the PF bad hosts tables."
print_separator
pasthours="$(date -u -v-6H)"
lasthours="$(date -j -f "%a %b %d %T %Z %Y" "${pasthours}" "+%H:%M")"
show_text ""
show_info "${lasthours}"
show_text ""
print_separator

# URL sources: plain list for POSIX shell
SOURCES="
drop_v4.json https://www.spamhaus.org/drop/drop_v4.json
drop_v6.json https://www.spamhaus.org/drop/drop_v6.json
asndrop.json https://www.spamhaus.org/drop/asndrop.json
torlist.txt https://www.dan.me.uk/torlist/?full
blocklist.txt https://lists.blocklist.de/lists/all.txt
"

fetch_data() {
  url="$1"
  output="$2"
  if ! "$CURL_CMD" --fail --silent --show-error --compressed --ignore-content-length \
    --header "User-Agent: $USER_AGENT" \
    --header "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
    --header "Accept-Encoding: gzip, deflate, br" --header "Accept-Language: en,de;q=0.5" \
    --header "DNT: 1" --header "Cache-Control: max-age=0" --header "Connection: keep-alive" \
    --header "Referer: https://localhost/" --tlsv1.2 --location "$url" --output "$output"
  then
    show_error "Failed to fetch $url"
    exit 1
  fi
}

# Download sources in parallel (using background jobs)
for entry in $SOURCES; do
  set -- $entry
  name="$1"
  url="$2"
  fetch_data "$url" "$TMP_DIR/$name" &
done
wait

# Preprocess blocklists
awk -F'"' '/cidr/ { print $4 }' "$TMP_DIR/drop_v4.json" > "$TMP_DIR/drop_v4.txt" &
awk -F'"' '/cidr/ { print $4 }' "$TMP_DIR/drop_v6.json" > "$TMP_DIR/drop_v6.txt" &
wait

awk -F'"' '/asn/ { print $3 }' "$TMP_DIR/asndrop.json" | sed -e 's|^:\([0-9]*\),$|AS\1|g' > "$TMP_DIR/asndrop.txt"

# Efficient parallel ASN-to-IP whois using xargs (POSIX: no function export, so inline)
: > "$TMP_DIR/asntoip.txt"
if [ -s "$TMP_DIR/asndrop.txt" ]; then
  grep -E '^AS[0-9]+$' "$TMP_DIR/asndrop.txt" | xargs -n 1 -P 8 sh -c '
    asn="$0"
    [ -z "$asn" ] && exit 0
    whois -h whois.radb.net -- "-i origin $asn" 2>/dev/null | awk "/^route/ { print \$2 }"
  ' > "$TMP_DIR/asntoip.txt"
fi

awk '!/^;/ { print "   " $1 }' "$TMP_DIR/drop_v4.txt" "$TMP_DIR/drop_v6.txt" "$TMP_DIR/asntoip.txt" | sort -u > "$TMP_DIR/badhosts_drop.tmp"
awk '!/^;/ { print "   " $1 }' "$TMP_DIR/torlist.txt" | sort -u > "$TMP_DIR/badhosts_torp.tmp"
awk '!/^;/ { print "   " $1 }' "$TMP_DIR/blocklist.txt" | sort -u > "$TMP_DIR/badhosts_misc.tmp"

####################################################################################
#                                 Table Handling                                   #
####################################################################################
replace_table() {
  table="$1"
  expire="$2"
  external="${3:-}"
  show_text ""
  print_separator
  show_info "Table $table"
  print_separator
  # Merge external input (if provided) and current table entries
  if [ -n "$external" ] && [ -f "$external" ]; then
    cat -- "$external" > "$TMP_DIR/$table.txt"
  else
    : > "$TMP_DIR/$table.txt"
  fi
  pfctl -t "$table" -T show >> "$TMP_DIR/$table.txt"
  sort -bu "$TMP_DIR/$table.txt" > "$TMP_DIR/$table.sorted"
  if [ "$dryrun" -eq 0 ]; then
    if ! pfctl -t "$table" -T replace -f "$TMP_DIR/$table.sorted"; then
      show_error "Failed to replace PF table $table"
      exit 1
    fi
    show_info "Updated table $table with $(wc -l < "$TMP_DIR/$table.sorted") entries."
    "$EXPIRETABLE_CMD" -v -t "$expire" "$table"
    show_text ""
    pfctl -t "$table" -v -T show
  else
    show_info "(Dry-run) Would update table $table with $(wc -l < "$TMP_DIR/$table.sorted") entries."
  fi
}

# Table definitions: "table_name:expire:optional_external_file"
TABLES="
badhosts_priv:90d:
badhosts_http:7d:
badhosts_mail:1d:
badhosts_sshd:6h:
badhosts_drop:90d:$TMP_DIR/badhosts_drop.tmp
badhosts_torp:2d:$TMP_DIR/badhosts_torp.tmp
badhosts_misc:2d:$TMP_DIR/badhosts_misc.tmp
"

# Loop over tables, POSIX compatible parsing
echo "$TABLES" | while IFS= read -r entry; do
  [ -z "$entry" ] && continue
  table=$(echo "$entry" | cut -d: -f1)
  expire=$(echo "$entry" | cut -d: -f2)
  external=$(echo "$entry" | cut -d: -f3)
  replace_table "$table" "$expire" "$external"
done

show_text ""
print_separator
show_info "PF Statistics"
print_separator
if [ "$dryrun" -eq 0 ]; then
  pfctl -v -v -s all
else
  show_info "(Dry-run) Would show PF stats"
fi
show_text ""
print_separator
show_info "Finished updating the PF bad hosts tables."
print_separator

exit 0
